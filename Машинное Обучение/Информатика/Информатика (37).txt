Многие приложения постоянно взаимодействуют с данными. Например, менеджеры для работы с фотографиями или приложение для социальных сетей. Android предоставляет ряд опций, в том числе: Shared Preferences, Internal Storage, External Storage, SQLite Databases для записи и хранения данных.

Когда данные структурированы, и нужно выполнить такие действия, как: поиск, изменение, удаление и выборка записей, база данных SQLite часто является лучшим выбором. Room — это библиотека-обертка SQLite от Google, которая удаляет большую часть стандартного кода, необходимого для взаимодействия с SQLite, а также добавляет проверку SQL-запросов во время компиляции [2].

При разработке приложения обычно используется объектно-ориентированный язык программирования, такой как Kotlin. Для представления данных, которые вы храните, используются классы. Далее создается необходимое количество экземпляров этого класса с уникальными данными.

В реляционной базе данных при использовании SQL мы должны смоделировать класс в виде таблицы. Каждый экземпляр этого объекта будет строкой в ​​этой таблице. Для хранения и извлечения этих данных в базу данных должны быть введены команды SQL, сообщающие ей о необходимости извлечения и сохранения данных (рис. 1):

INSERT INTO Persons (имя, адрес, номер телефона)

VALUES («Grumpy Cat», «1 Tuna Way, Los Angeles CA», «310-867-5309»);

В первые дни существования Android для POJO класса Person, который нужно сохранить в базе данных SQLite, пришлось бы создавать связующий код для превращения объектов в SQL, а SQL в объекты.

Задолго до появления Android разработчики других объектно-ориентированных языков начали использовать класс инструментов, называемый ORM, для решения этой проблемы. ORM расшифровывается как Object Relational Mapper. Это инструмент, предназначенный для автоматического создания связующего кода для сопоставления между экземплярами вашего объекта и строками в вашей базе данных.

Когда появился Android, ORM для среды Android не существовало. За эти годы появились платформы с открытым исходным кодом, в том числе DBFlow, GreenDAO, OrmLite, SugarORM и Active Android. Несмотря на то, что эти решения помогли решить основную проблему сокращения связующего кода, сообщество разработчиков никогда не стремилось к одному (или двум) общим решениям. Это привело к значительной фрагментации и ограничениям во многих из этих сред, особенно с более сложными жизненными циклами приложений.

В 2017 году компания Google создала структуру под названием Компоненты архитектуры Android. В эту структуру была включена новая библиотека Room. С Room у разработчиков есть ORM для генерации связующего кода (рис. 2).

Объект содержит данные для использования в приложениях с некоторой дополнительной информацией, чтобы сообщить библиотеке о его структуре в базе данных. Для начала создается сущность для хранения полей category_name и id в таблице с именем list_categories.

@Entity(tableName = "list_categories")

data class ​ListCategory

(

@ColumnInfo(name="category_name") var categoryName: String,

@ColumnInfo(name="id") @PrimaryKey(autoGenerate = true) var id: Long = 0

)

Благодаря аннотации @Entity(tableName = "list_categories") мы помечаем данный класс как объект Entity, а @ColumnName(name="category_name") – имя столбца в таблице. Если не задать название столбца с помощью аннотации, то название будет эквивалентно названию поля в POJO классе.

После создания объекта, отмеченного как @Entity, понадобится интерфейс для взаимодействия с ним. В этом объекте находятся методы для работы с базой данных. Для этого создается интерфейс с произвольным именем и помечается аннотацией @Dao. Благодаря этому, Room сама создаст необходимую реализацию за вас.

@Dao

interface ListCategoryDao

{

@Query("SELECT * FROM list_categories")

fun getAll(): List<ListCategory>

@Insert

fun insert(var listCategories: ListCategory)

}

Аннотация @Query свидетельствует, что нужно выполнить SQL запрос в данном методе getAll(). В данном случае он извлекает все записи в list_categories таблице. Метод возвращает экземпляр класс ArrayList потому, что Room просматривает результаты запроса и сопоставляет любые возможные поля с указанными типом возвращающего значения [1]. В результате мы получим все записи из таблицы в виде списка объектов. Если библиотеке не получается сопоставить поля таблицы с возвращаемым значением, она выдаст предупреждение CURSOR_MISMATCH и продолжит подбирать уместные поля.

Метод insert аннотирован @Insert. Это говорит о том, что Room сама сгенерирует необходимый SQL запрос для добавления данных в таблицу.

Теперь, когда созданы такие объекты как Entity и Dao, нам понадобится объект самой базы данных, чтобы связать одно с другим. Для этого создается новый класс с произвольным именем, который наследует RoomDatabase.

@Database(entities = [(ListCategory::class)], version = 1)

abstract class AppDatabase : RoomDatabase()

{

  abstract fun listCategoryDao(): ListCategoryDao

}

Добавляем аннотацию @Database и в entities указываем созданный ранее Entity, что показывает, какие объекты ассоциированы с этой базой данных. Существует также значение version, установленное на 1. При выполнении миграции базы данных необходимо будет изменить версию базы данных. Абстрактный метод listCategoryDao() возвращает экземпляр ранее созданного объекта Dao.

Чтобы начать взаимодействовать с базой данных, нужно создать ее экземпляр в приложении. Мы реализовали всего три коротких необходимых класса, и Room сам проделает большую работу, чтобы управлять, отображать и генерировать SQL запросы. Однако из-за этого экземпляр Room является ресурсоемким, поэтому разработчики рекомендуют использовать один экземпляр на все приложение. Для этого можно применить синглтон класс [3]. Для Android создать класс, наследуемый от Application, и прописать его автозапуск в манифесте.

class ListMasterApplication: Application()

{

companion object

{

                     var database: AppDatabase? = null

           }

  override fun onCreate()

{

                     super.onCreate()

                     ListMasterApplication.database = Room.databaseBuilder(this, AppDatabase::class.java, "list-master-db").build()

           }

}

Рассматривая вызов для создания экземпляра базы данных, были переданы три параметра. Ссылка на контекст приложения, ссылка на класс базы данных и имя. За кулисами это имя соответствует имени файла, которое используется для хранения вашей базы данных во внутренней памяти.

Далее мы можем получить ссылку на экземпляр класса AppDatabase с синглтон класса ListMasterApplication, а затем экземпляр ListCategoryDao, через который мы будем взаимодействовать с нашей базой данных:

appDatabase = ListMasterApplication.database !!

listCategoryDao = appDatabase.listCategoryDao ()

Теперь мы можем вызывать методы класса listCategoryDao для работы с нашей базой данных. Например, для добавления записи используем метод insert:

listCategoryDao.insert (ListCategory(“Фантастика”))

В результате будет добавлена запись в базу данных с полями category_name и id. Благодаря аннотации @PrimaryKey(autoGenerate = true) в нашем классе ListCategory над полем var id: Long, уникальный ключ будет сгенерирован автоматически.
