зыковая модель исполнимых кодов

ПО аналогии с методами сравнения естественных языков строится языковая модель исполнимого кода на основе однородных Марковских цепей и приводятся результаты экспериментальных исследований предложенной модели. Ключевые слова: машинный код, Марковские цепи, классификация.

Введение. В настоящее время существует множество задач, при решении которых необходимо применять методы анализа и трансформации программ. Это задачи обеспечения безопасности программ, генерации и верификации исходных кодов, а также обратной инженерии. С целью решения таких задач используются дизассемблеры и декомпиляторы, при работе которых встает целый ряд подзадач, уже имеющих решения на текущий момент. Однако существуют и задачи, требующие более эффективных решений, чем существующие. Одна из таких задач - разделение неопределенных участков программ на код и данные.

В работе [1] описывается результативность существующих методов разделения таких участков, суть которых сводится к сигнатурному анализу, не способному полностью решать поставленную проблему. В данной статье проверяется гипотеза, что однородные Марковские модели первого порядка смогут эффективно моделировать исполнимый код для задачи разделения неопределенных участков программ на код и данные, и исследуется эффективность метода на практике.

Основной текст. Любую последовательность байт длины более 16, согласно спецификации Intel IA-32 [2], можно дизассемблировать как последовательность команд, причем единственным образом. Если дизассемблирование производить с разных позиций, то появится эффект наложения команд, детально описанный в статье [3], при котором один и тот же байт может входить в несколько исполнимых команд, как показано в табл. 1.

Таблица 1

Эффект наложения команд

Двоичное представление кода 14 53 Последовательность 1 Последовательность 2 Последовательность 3

add esp, 14

push ebx

83 ec 0c sub esp, c sub esp, c

or al, 8b

8b 5c 24 14 mov ebx, 14 mov ebx, 14

pop esp

and al, 14

8b 53 04 mov edx, 4 mov edx, 4 mov edx, 4

8b 0b mov ecx, ebx mov ecx, ebx mov ecx, ebx

Дизассемблированные иструкции

Следовательно, одна и та же последовательность байт может формировать различные последовательности исполнимых команд в зависимости от позиции начала дизассемблиро-вания. Указанный факт является основной проблемой в задаче разделения неопределенных участков программ на код и данные, т.к. любой фрагмент данных можно интерпретировать как код, хотя он таковым не является, и при его исполнении на центральном процессоре произойдет ошибка выполнения.

Так как код программы представляет собой логически завершенную последовательность команд, реализующую конкретный алгоритм на языке высокого уровня, то порядок команд строго фиксирован в цепочке и логически упорядочен. Указанная семантическая особенность команд исполнимого кода является их специфическим отличием от команд, полученных при дизассемблировании случайного фрагмента данных. Аналогич-

но в естественных языках слова в предложениях, как правило, имеют упорядоченность на основе семантики и синтаксиса языка. Некоторые комбинации слов и букв соответствуют различным языкам.

Пример корректной исполнимой последовательности команд языка Ассемблер представлен в табл. 2.

Таблица 2

Пример корректной исполнимой последовательности команд

Байт код команд Команда Значение

55 8B EC 83 EC 18 PUSH EBP MOV EBP,ESP SUB ESP,18 Стандартный код начала функции

6A 00 6A 00 6A 00 E8 23 24 FE FF PUSH 0 PUSH 0 PUSH 0 CALL 00445606 Передача параметров Вызов функции

85 C0 0F 84 F0 9D FD FF TEST EAX,EAX JE SHORT 0043CFDB Проверка условия Условный переход

В приведенной таблице показано, что первые три команды, как правило, представляют начало функции, три «push» и «call» представляют собой вызов функции с передачей ей параметров, а «test» и «je» представляют собой проверку условия и условный переход. Жирным выделены значения в байтовой последовательности, отвечающие за сами команды, оставшиеся байты - параметры команд.

В лингвистике одним из наиболее успешных методов определения языка по тексту (из конечного числа языков) являются Марковские модели [4]. В данной работе на основе аналогии с методами сравнения естественных языков проверяется гипотеза, что однородные Марковские модели первого порядка смогут эффективно моделировать исполнимый код в задаче разделения неопределенных участков программ на код и данные.
За последовательность дискретных случайных величин {Xn}, n > 0 примем последовательность команд (без параметров), в которой

P(Xn+1 = in+1 \ Xn = in, Xn-1 = in-1, ••, X0 = i0) = P(Xn+1 = in+1 \ Xn = in), (1)

т.е. на вероятность появления следующей команды в цепочке влияет только текущая команда. Тогда {Xn} образует однородную Марковскую цепь первого порядка, в которой n -номер команды в последовательности. На начальном этапе проверки гипотезы матрицу переходных вероятностей Pj(n) = P(Xn+i = j \ Xn = i) построим на основе серии экспериментов. Тогда, приняв за {Oj}, j = 0...L - тестируемую последовательность команд, которую необходимо классифицировать, вероятность принадлежности ее определенной модели M будет выражаться по формуле

Pm(O) = Pm(Oi)x PM(02\0I) х PM(03^) X ... x PmOOl-I)- (2)

Отметим, что если {Oj} представляет собой корректную исполнимую последовательность команд длиной L, то существует только одна последовательность байт {Bj}, представляющая эту последовательность.

Основываясь на том факте, что в теле программы код функции может начинаться в любой позиции файла, можно получить несколько его интерпретаций в виде последовательностей команд. Различие в интерпретации будет определяться позицией дизассембли-рования первой команды последовательности. В работе [3] изучен и доказан тот факт, что дизассемблированные последовательности команд, начатые с разных позиций файла (как показано в табл. 1), сойдутся с большой вероятностью менее чем через 32 байта в одну последовательность. Следовательно, для любого фрагмента программы более 64 байт можно получить последовательность команд {Oj} длиной L, из которых первые K (< 32 < L) будут командами «схождения» (различными командами на одинаковых позициях последовательностей), а оставшиеся L — K команд будут истинными командами последовательности при дизассемблировании. Следовательно, при полном дизассемблировании фрагмента длиной более 64 байт можно с большой вероятностью получить истинную последовательность команд, которую она представляет, либо построить ложную последовательность, не характерную для исполнимых файлов.

Экспериментальные исследования. Построим модели исполнимых и неисполнимых последовательностей команд. Матрицы переходных вероятностей моделей изначально предлагается строить обучением на основе выборок файлов. Команды обоих видов моде-

лей на первом шаге примем равновероятными. Обучаемую выборку файлов (для построения матриц переходных вероятностей) будут представлять набор из исполнимых файлов формата Windows PE и различные файлы неисполнимых форматов. Согласно проводимому в работе сравнению естественных языков и машинного, по аналогии с разбиением текстов естественных языков на корпуса [4], разделим исполнимые и неисполнимые файлы обучаемой выборки на классы и для каждого класса на основе описанного ниже алгоритма построим языковую модель, представляющую данный класс.

Для построения матрицы переходных вероятностей модели исполнимых файлов необходимо получить последовательности команд исполнимых файлов. Для этого необходимо построить граф потока управления и команд, начиная с точки входа в программу, и выделить все пути как корректные последовательности команд для обучения модели исполнимых файлов.

Для проверки, какой модели соответствует тестируемый файл (участок программы), предлагается следующий алгоритм:

1. Для каждой позиции файла строится дизассемблированная команда, начатая в этой позиции (на основе спецификации Intel IA-32 [2]).

2. Для каждой позиции файла строится последовательность команд, которая обрывается на позиции, с которой невозможно получить корректную команду.

3. На основе последовательностей, найденных в п. 2, формируются все возможные их подпоследовательности команд Sj длины T.

4. Для каждой подпоследовательности команд Sj по формуле (2) вычисляются вероятности соответствия исполнимым классам моделей. Среди всех подпоследовательностей выбирается одна S', с самой большой вероятностью для любой модели исполнимого класса.

5. Найденная подпоследовательность S', имеющая максимальную вероятность среди исполнимых моделей на файл (наилучший кандидат на исполнимую последовательность команд), аналогично п. 4 проверяется на соответствие оставшимся моделям неисполнимых классов.

6. Подпоследовательность команд S' будем считать исполнимой, если она наиболее вероятна какому-нибудь классу исполнимой модели, иначе она считается неисполнимой.

7. Тестируемый фрагмент файла, участок программы будем считать исполнимым, если S' была принята за исполнимую подпоследовательность, иначе - не исполнимым.

Описанный алгоритм позволяет классифицировать неопределенные участки программ на код и данные. Минимальная длина подпоследовательности команд, которая используется при классификации, определяется экспериментально.

Подготовка выборки файлов для обучения моделей. Для формирования моделей было отобрано 23126 исполнимых и 62883 неисполнимых файлов. С помощью средства PeID (сигнатурный детектор компиляторов и упаковщиков программ [5]) вся выборка исполнимых файлов была разделена на 13 классов. Неисполнимая выборка была разделена по формату файлов на 3 класса. Тестируемую выборку представлял набор из 30 файлов, не входящих в обучаемую: 15 исполнимых и 15 неисполнимых форматов. В моделях было 342 уникальные команды.

Условия эксперимента. Для проведения экспериментов использовался алгоритм, описанный выше, с тем изменением, что сначала длина T находилась экспериментально. Алгоритм прекращал работу, как только все файлы обучаемой выборки успешно классифицируются. Было установлено, что при T > 30 обучаемая выборка успешно классифицируется.

При построении матриц переходных вероятностей моделей на основе встречаемости команд в подпоследовательностях возможен случай, когда паросочетание команд встречается в одной модели и отсутствует в другой. Согласно свойствам матриц переходных ве-H

роятностей, ^ Pij (n) = 1,Vn eN для каждого j, где H - общее количество уникальных ко-

j=1

манд. После нахождения частот встречаемости паросочетаний команд, каждая модель дополняется нулями для соответствующих пар, далее матрица переходных вероятностей нормируется и приводится к стохастическому виду. При нормировании используется формула

Pij(n) = Pij(n) х K + 1, (3)

где K = 2х(М - 1) - коэффициент нормирования; М - количество различных уникальных команд в цепочках.

В табл. 3 представлена нормированная и приведенная к стохастическому виду матрица переходных вероятностей Р^(п) для Марковской модели последовательности команд из табл. 2.

Таблица 3

Стохастическая матрица переходных вероятностей