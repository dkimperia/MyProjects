   Очевидно, что создание высокопроизводительных вычислительных систем входит в число важнейших программ ведущих государств мира. Без суперкомпьютеров невозможно обеспечить конкурентоспособность страны на мировом рынке,  проводить современные научные изыскания в самых различных областях знаний.             Как  бы не показалось  странным на первый взгляд, но вычислительная мощность компьютерных систем за время их существования выросла, главным образом, далеко не за счет технологического развития. Ведь если со времен первых компьютеров (EDSAC, Кембридж, 1949 год) и до наших дней (суперкомпьютер Hewlett-Packard V2600) время такта выросло с 2 микросекунд  до 1,8 наносекунды и прирост составил 1000 раз, то производительность выросла, соответственно, со 100 арифметических операций в секунду до 77 миллиардов. Прирост составляет более чем семьсот миллионов раз. Откуда же тогда взялась такая существенная разница? Ответ очевиден – от использования новых решений в архитектуре компьютеров.             Тем не менее, в настоящее время все отчетливее зреет понимание того, что и развитие архитектурных решений близко к своему пределу. К тому же,  эффективно использовать все более усложняющиеся системы становится  труднее. Назревающий кризис толкает исследователей на поиск принципиально новых архитектурных решений, основанных на нефоннеймановских принципах, которые отличались бы логической простотой и регулярностью,  пусть даже за счет увеличения общего объема оборудования.  При этом усилия части исследователей и разработчиков сосредоточились на проектировании матричных структур с изменяемыми  межпроцессорными  связями – так называемых реконфигурируемых вычислительных структурах (РВС), которые должны обеспечить высокую производительность вычислительной системы на уровне пиковой для широкого класса задач, а также линейный рост производительности при увеличении числа процессоров в системе. Вообще говоря, любой мультипроцессорной архитектуре с жесткими межпроцессорными связями присущ один и тот же органический недостаток: наивысшей производительности, близкой к пиковой,  она способна достичь  только для какого-то узкого класса задач. И производительность которой имеет свойство  падать, уменьшаясь на порядок-два, для задач других классов. Эта проблема имеет системный характер и является следствием неадекватности каждой конкретной архитектуры вычислительной системы внутренней структуре решаемой задачи. Вообще говоря,   любую задачу пользователя можно представить системой S, процессы в которой  описаны  формой информационного графа (рис. 1а). Граф G(Q,X) содержит множество вершин giQ, каждой из которых приписана некоторая операция Oi, принадлежащая множеству допустимых операций O.Дуги графа определяют последовательность выполнения операций, приписанных вершинам. Множество входных дуг определяют источник входных данных, выходных – приемник результатов решения.     При исполнении задачи S в среде мультипроцессорной системы (S*), в последней организуется вычислительный процесс, который можно описать информационным графом G*(Q*,X*).  Здесь множество вершин Q* определяется множеством процессоров вычислительной системы, а множество дуг X* представляет собой множество каналов коммуникаций между процессорами. В свою очередь, входные и выходные дуги определяются каналами связи  с источником входных и приемником выходных данных. Как правило,  графы G и G* существенно отличаются один от другого. Объяснение этому можно найти в том, что жесткая архитектура многопроцессорной вычислительной системы S* в большинстве случаев значительно отличается от структуры пользовательской задачи S. В результате,  системой S*   приходится организовывать некоторый мультипроцедурный процесс, который моделирует систему S, но структурно с ней не совпадает. Результатом такого моделирования становится то, что граф G* оказывается намного сложнее, чем исходный граф G.  Все это приводит к существенным потерям времени за счет операций распределения заданий и процедур между процессорами вычислительной системы,   очередей,  конфликтов и т.д. Указанного недостатка вычислительной системы с "жесткой" архитектурой можно избежать,  если обеспечить возможность ее реконфигурации таким образом, чтобы граф G* вычислительного процесса как можно ближе совпадал с графом G решаемой задачи. Суть концепции РВС в том и заключается,  чтобы архитектура вычислительной системы имела возможность адаптироваться под структуру решаемой задачи. В отличие от многопроцессорных вычислительных систем с жесткими межпроцессорными связями, а также кластерных систем, архитектура связей реконфигурируемых вычислителей может изменяться в процессе их функционирования. В результате у пользователя появляется возможность адаптации архитектуры вычислительной системы под структуру решаемой задачи. В качестве наиболее подходящей среды реализации идеи  используются микросхемы программируемой логики (ПЛИС), как устройств наивысшей степени параллельного действия, известных на сегодняшний день. К тому же применение ПЛИС обеспечивает ускорение вычислительного процесса по сравнению с микропроцессором от 5 до 100 раз вследствие адаптации внутренней вычислительной структуры к информационной структуре решаемой задачи. Можно сказать, что идея РВС в настоящее время завоевывает все большее число сторонников и более того,  воспринимается многими именно той "фишкой",  которая  ляжет в  основу архитектуры ЭВМ нового типа. Тем не менее, как на мой взгляд, "всенародная любовь" эта является скорее вынужденной, что можно объяснить  просто отсутствием должной альтернативы, чем совершенством имеющегося  метода. Потому как у изначально красивой идеи, на этапе реализации обнаружилось немало системных проблем. Поэтому показательным выглядит то,  что несмотря на большое число исследований в области реконфигурируемых структур, они до сих пор так и не нашли  широкого применения. В том числе это объясняется специфичностью и достаточной сложностью программирования таких систем, наличием нестандартных и сложнейших средств программирования, а также требованием к нестандартному мышлению программиста. Процесс разработки реконфигурируемой структуры трудоемкий, требующий от пользователя больших временных затрат,  а также специальных знаний и, по сути, квалификации схемотехника. По степени  сложности программирование РВС сопоставимо с разработкой новой вычислительной среды. Отчего использование таких систем структур для решения часто меняющихся задач оказывается малоэффективным. В то же время,  преимущество идеи реконфигурирования в полной мере проявилось пока на решениях только некоторых классов параллельных задач, таких как потоковые,  в которых большие массивы данных обрабатываются по одному и тому же алгоритму – обработки сигналов, криптографии и т.п.  Так что о широком классе решаемых задач говорить пока тоже рановато. В особенности, если учесть, что современные приложения зачастую образуют сложную иерархию параллельно-последовательных процессов, да еще и меняющихся во времени. Представляемая на суд читателя статья является, по сути, первой попыткой заявить вслуг, что нет смысла и дальше бороться с "ветряными мельницами". Потому что на самом деле есть другой путь – более дешевый,  эффективный, надежный и доступный каждому! И, к тому же, свободный от каких-либо системных "болезней". Путь, который почему-то совершенно выпал из поля зрения идеологов и разработчиков вычислительных систем, имя которому – моделирование. Я преднамеренно выше, при рассмотрении идеи несовпадения графов задачи и исполняющей системы,  выделил жирным курсивом слово "моделирует", потому что все идеологи архитектур его видят (и пишут про него), но при этом всеми силами с ним борются,  выбрав за основу развития  – реконфигурацию. Притом, как оказалось, путь тернистый, усеянный множеством трудноразрешимых преград. Целью данной статьи есть стремление показать, что именно идея моделирования, предварительно развитая автором до понятия эмуляции алгоритмов и систем, обладает поразительной возможностью к развитию. Она открывает альтернативный подход к проектированию вычислительных систем, основанный на том, что заниматься реконфигурированием их среды каждый раз заново от задачи к задаче – как раз и не нужно! Достаточно  только один раз "заточить" ее под структуру авторского модуля схемной эмуляции, а потом просто эмулировать задачи пользователей, элементарно загружая их в уже подготовленную среду. В этом случае отпадает всякая необходимость ценой неимоверных аппаратно-программных усилий стремиться подогнать структуру вычислительной системы (S*) к структуре пользовательской задачи (S), потому что в среде эмуляции мы уже непосредственно работаем с исходным информационным графом задачи пользователя (G). Предлагаемый подход прост в реализации и совершенно свободен от недостатков, которыми в избытке наделены абсолютно все известные архитектуры, включая  и  реконфигурируемые вычислительные структуры.             Не менее интересной прелестью предлагаемой к рассмотрению архитектуры является практически абсолютная ее способность к так называемому масштабированию. Это означает, что ее вычислительная мощность растет практически линейно включенному в архитектуру оборудованию, состоящего, к тому же, из однотипных узлов.  Можно сказать,  что высокая степень масштабирования с легкостью позволяет практически разрешить наверно самый глобальный недостаток известных суперкомпьютеров – чрезвычайно малый срок морального устаревания,  составляющий примерно пять лет.             Для изделий,  чья стоимость начинается от сотен тысяч долларов и достигает десятков миллионов – это очень важный фактор, заметно сдерживающий развитие суперкомпьютерной отрасли в целом!             Суперкомпьютер, спроектированный в соответствии с предлагаемой автором идеей,  в заметно меньшей степени будет зависеть от такого понятия  как  срок морального устаревания. Корнями идея эмуляции алгоритмов и систем уходит к классу программных продуктов, известных как схемные симуляторы.   В  качестве примера  можно упомянуть такие, как   Micro-CAP от "Spectrum SoftWare",  PSpice  от  "MicroSim Corp." и т.д.,  которые  у нас еще принято называть программами моделирования  электронных  устройств.  Исторически симуляторы появились в ответ на законное желание разработчиков иметь возможность проверять работу спроектированной ими схемы до того, как она будет реализована с помощью паяльника. В таких программах уровни входных сигналов, выбираемые  из так называемого массива входных воздействий, шаг за шагом подаются на вход программной  модели устройства.  Разумеется, что само слово "массив" – это атрибут программистских "штучек" и не имеет ни малейшего отношения к реальным сигналам. Под моделированием понимается этап имитации поведения схемы устройства (в масштабах условной временной шкалы) на уровне ее программной модели с соблюдением всей динамики протекающих в устройстве процессов. Проектирование  можно  считать выполненным правильно в случае, если получены правильные временные соотношения для уровней сигналов во  всех цепях устройства.  Результатом  моделирования  становится также некий  массив  уровней сигналов в цепях  схемы, который можно затем вывести на принтер или дисплей в виде графиков. А что же тогда есть эмуляция?  Эмуляция – это моделирование, выполняемое в режиме реального времени и в реальной среде  окружения. Для того чтобы программа схемотехнического моделирования превратилась в программу схемной эмуляции необходимо выполнение некоторых условий. Первое -   добиться того, чтобы программа моделирования работала не с программными массивами,  а с реальными сигналами.  В этом случае на вход программной модели должны подаваться  не комбинации входных событий,  выбираемых из программного массива, а  уровни  сигналов с реальных периферийных систем. В тоже время, отклики, снимаемые с программной модели, опять-таки, должны подаваться в реальное окружение. Второе -  добиться того, чтобы программа моделирования работала в режиме реального времени, а не какой-либо условной временной шкале. Потому что эмуляция – это имитация  поведения  электронного  устройства,  как будто его схема  уже реализована с помощью паяльника. Под "режимом реального времени" следует понимать случай,  когда скорость имитации становится соизмеримой  со скоростью изменения процессов в реальном объекте управления. Другими словами, когда отклик,  снимаемый  с программной модели, будет поспевать  за  процессами,  протекающими в реальной среде окружения.  Третье – сделать так, чтобы программа моделирования не требовала ресурсов PC. Соблюдение этого условия позволит размещать ее не только на PC платформах, но и во встраиваемых системах.  Программу схемотехнического моделирования, удовлетворяющую выполнению вышеперечислен-ных условий, уже по праву можно назвать – программой схемной эмуляции. В  основу  предлагаемой мною системы  положен    авторский   алгоритм  схемной эмуляции,    реализованный   в  авторском  программном  продукте - модуле схемной  эмуляции.   В тоже время,  разработанный и программно реализованный мною алгоритм,  успешно выполняет еще одно условие – в основу его работы положен  принцип параллельных потоков. Конечно же,  в среде PC платформ или встраиваемых микропроцессоров, принцип многопоточности может только имитироваться. Для наиболее же полного раскрытия свойств алгоритма требуется и среда параллельного действия. К счастью, в настоящее время  реализация такой среды известна – это т.н. матрицы  вентильных массивов  FPGA (Field-Programmable Gate Arrays) микросхем программируемой логики (ПЛИС). Именно соединение этих двух компонент – авторского модуля схемной эмуляции                          (реализованного на  принципах  многопоточности), и матрицы вентильных массивов (как устройства параллельного действия),  открывает широчайшие  возможности для создания действительно принципиально новой вычислительной среды – системы эмуляции задач пользователей, представленных в графическом виде.     В соответствии с идеологией системы эмуляции,  модуль схемной эмуляции,  по сути, выполняет функцию системы исполнения задач пользователей, представленных в графическом виде. Уровень представления задач здесь допускается самый разный:  от графов, сетей,  алгоритмов и специальных языков графического программирования - до функциональных и структурных схем. В конце концов – это может быть принципиальная схема электронного устройства, реализующего некий алгоритм. Поскольку в теории реконфигурируемых систем отталкиваются от такого уровня как графы алгоритмов, то и я в рамках данной статьи привяжусь именно к этому уровню. Да и пронаблюдать сравнительный анализ двух архитектур в этом случае будет значительно проще. Исполнить задачу в системе эмуляции –  означает эмулировать (имитировать поведение  в режиме реального времени и реальноой среды окружения) графический рисунок  пользователя, в соответствии с тем, как сам пользователь мог бы представить его работу в своем воображении. Только модуль эмуляции сделает это точно и без ошибок. Красота идеи состоит в том, что при этом пользователю не нужно браться за паяльник, чтобы реализовать свою задачу аппаратно,  или пытаться реализовать ее программным способом. Вообще говоря, возможность реализовать алгоритмы аппаратными или программными способами издавна называется дуализмом (Э.Э. Клингман). До сегодняшнего дня развитие технических систем проходило именно в соответствии с этим принципом.  Идея схемной эмуляции впервые открывает пользователю новый (третий) путь реализации его проектов – просто имитацией их поведения в принципиально новой среде – среде графического исполнения, основанной на принципах схемной эмуляции. Особенностью архитектуры системы эмуляции, построенной  на основе кристалла ПЛИС, есть то, что в распоряжение пользователя предоставляется не "голый" кристалл, который ему еще каким-то образом необходимо запрограммировать. А такой, в котором рабочая область уже предварительно "отформатирована" структурой модуля эмуляции,  и в которую пользователю достаточно только загрузить описание графической схемы  своей задачи. Однако прежде чем переходить к презентации своей идеи, мне хотелось бы привести краткое описание сути самих реконфигурируемых вычислительных структур. Потому что именно в сравнительном анализе читателю в полной мере раскроются преимущества представляемого мною подхода. С другой стороны, не смотря на то, что в глобальной сети можно найти мегатонны текстов, посвященных реконфигурируемым структурам, идея эта все еще остается достаточно специфической и вряд ли знакомой широкому кругу специалистов. Поэтому я не вижу смысла  отвлекать внимание читателя на поиск и изучение  материалов по данной теме, а предлагаю сразу, в рамках данной статьи, ознакомиться с моей реферативной подборкой. Которая, конечно, не претендует на глубину изложения, но для понятия сути  вопроса является вполне достаточной. Приведенный мною материал касательно реконфигурируемых структур изложен на основании статей таких  идеологов, как:   И.А. Каляев (НИИ многопроцессорных вычислительных систем  Южного федерального университета,  г. Таганрог, Россия),  И.И. Левин, Е.А. Семерников (Южный научный центр РАН, г. Ростов-на-Дону, Россия),   А.В Палагин  (Институт кибернетики им. В.М. Глушкова НАН Украины) и других. Архитектура  реконфигурируемых  вычислительных  структур Таким образом,  регулярность вычислительной структуры еще не является залогом ее высокой производительности на широком классе задач. Необходимым условием следует считать также  возможность ее реконфигурации, чтобы граф G* вычислительного процесса как можно ближе совпадал с графом G решаемой задачи. Суть концепции РВС в том и заключается,  чтобы архитектура вычислительной системы имела возможность адаптироваться под структуру решаемой задачи. В отличие от многопроцессорных вычислительных систем с жесткими межпроцессорными связями, а также кластерных систем, архитектура связей реконфигурируемых вычислителей может изменяться в процессе их функционирования. В результате у пользователя появляется возможность адаптации архитектуры вычислительной системы под структуру решаемой задачи. В отличие от традиционных методов организации параллельных вычислений РВС ориентируются на абсолютно параллельную форму алгоритма задачи – ее информационный граф. Под информационным графом понимается граф, вершинам которого соответствуют арифметико-логические операции над операндами. Дуги информационного графа соответствуют информационной зависимости между вершинами и, по сути, определяют порядок соединения вычислителей. Таким образом, идея концепции РВС заключается в аппаратной реализации всех операций, предписанных вершинами информационного графа, и всех каналов передачи данных между вершинами,  соответствующих дугам графа. Такое решение задачи принято называть структурным. Наиболее наглядно идею РВС можно продемонстрировать на примере т.н. однородной мультимикроконвейерной вычислительной среды, представляющую собой матрицу однотипных (как правило однобитных)   процессоров.             Суть этого подхода заключается в создании мультиконвейера с жесткой архитектурой и обеспечении коммутационных возможностей за счет придания каждому процессору дополнительных функций транзитной передачи информации.  В такую структуру можно отобразить любой граф алгоритма G(Q,X),  как показано на  рис.1  При этом, как можно заметить из рисунка,  часть процессоров будет занята неэффективной работой  транзита входной информации к другим узлам структуры, а часть процессоров  не будут заняты никакими процессами вообще.  К тому же,  транзит информации через процессоры вносит дополнительные временные задержки при прохождении данных через мультиконвейер,  снижая тем самым темп конвейерной обработки.  Кроме того, процесс отображения исходного графа в матричную структуру с жесткой архитектурой является нетривиальной задачей.  Очевидным есть и то, что в такой структуре невозможно поместить граф реальной задачи, состоящий из сотен, тысяч и миллионов вершин.  Эффективность рассматриваемой архитектуры можно было бы увеличить, применив полнодоступный коммутатор, обеспечивающий возможность полнодоступной коммутации между всеми процессорами мультимикроконвейера.  Однако, аппаратные затраты на его реализацию будут недопустимо велики, потому как пропорциональны квадрату числа процессоров.